{"version":3,"sources":["com/fulcrologic/fulcro/routing/dynamic_routing.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.routing.dynamic-routing/*target-class*","com.fulcrologic.fulcro.routing.dynamic-routing/route-segment","class","result","com.fulcrologic.fulcro.raw.components.component_options","and__5043__auto__","js/goog.DEBUG","cljs.core/vector?","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","com.fulcrologic.fulcro.routing.dynamic-routing/get-route-cancelled","com.fulcrologic.fulcro.routing.dynamic-routing/route-cancelled","route-params","temp__5804__auto__","f","*target-class*-orig-val__44976","*target-class*-temp-val__44977","com.fulcrologic.fulcro.routing.dynamic-routing/get-will-enter","temp__5802__auto__","will-enter","ident","com.fulcrologic.fulcro.raw.components.get_ident","com.fulcrologic.fulcro.raw.components/component-name","_","com.fulcrologic.fulcro.routing.dynamic-routing/route-immediate","com.fulcrologic.fulcro.routing.dynamic-routing/will-enter","app","params","*target-class*-orig-val__44978","*target-class*-temp-val__44979","com.fulcrologic.fulcro.routing.dynamic-routing/route-target?","component","cljs.core/boolean","com.fulcrologic.fulcro.routing.dynamic-routing/get-will-leave","this","or__5045__auto__","cljs.core/constantly","com.fulcrologic.fulcro.routing.dynamic-routing/will-leave","c","props","*target-class*-orig-val__44980","*target-class*-temp-val__44981","com.fulcrologic.fulcro.raw.components.isoget","com.fulcrologic.fulcro.routing.dynamic-routing/get-allow-route-change?","will-leave","G__44982","G__44983","com.fulcrologic.fulcro.raw.components/props","com.fulcrologic.fulcro.routing.dynamic-routing/allow-route-change?","e44984","*target-class*-orig-val__44985","*target-class*-temp-val__44986","e","cljs.core/ex-message","com.fulcrologic.fulcro.routing.dynamic-routing/route-lifecycle?","com.fulcrologic.fulcro.routing.dynamic-routing/get-targets","router","cljs.core/set","p__44987","p__44988","vec__44989","cljs.core.nth","vec__44992","com.fulcrologic.fulcro.routing.dynamic-routing/ident-matches-expectation?","expected-table","maybe-expected-id","table","id","cljs.core._EQ_","com.fulcrologic.fulcro.routing.dynamic-routing/check-ident-matches-expectation?","fn-name","com.fulcrologic.fulcro.raw.components/ident","cljs.core/first","cljs.core/with-meta","com.fulcrologic.fulcro.routing.dynamic-routing/route-deferred","completion-fn","com.fulcrologic.fulcro.routing.dynamic-routing/immediate?","G__44995","cljs.core/meta","var_args","G__44997","com.fulcrologic.fulcro.routing.dynamic-routing/route-with-path-ordered-transaction","js/Error","p__44998","map__44999","cljs.core/--destructure-map","cljs.core.get","txn","com.fulcrologic.fulcro.routing.dynamic_routing.route_with_path_ordered_transaction","optimistic?","route-immediate?","options","p__45000","map__45001","com.fulcrologic.fulcro.routing.dynamic-routing/apply-route*","state-map","target","router-class","router-id","cljs.core/second","target-class","cljs.core/assoc-in","cljs.core.conj","cljs.core.update_in","cljs.core/dissoc","com.fulcrologic.fulcro.raw.components/set-query*","com.fulcrologic.fulcro.raw.components.get_query","com.fulcrologic.fulcro.routing.dynamic-routing/router-for-pending-target","routers","G__45002","cljs.core/vals","cljs.core.reduce","r","G__45003","cljs.core/reduced","com.fulcrologic.fulcro.routing.dynamic-routing/target-ready","com.fulcrologic.fulcro.mutations/->Mutation","com.fulcrologic.fulcro.mutations/mutate","fulcro-mutation-env-symbol","map__45004","p__45005","map__45006","*after-render*-orig-val__45007","com.fulcrologic.fulcro.raw.components/*after-render*","*after-render*-temp-val__45008","env","*after-render*-orig-val__45009","*after-render*-temp-val__45010","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","default-action","com.fulcrologic.fulcro.application.current_state","cljs.core.get_in","com.fulcrologic.fulcro.ui_state_machines.trigger_BANG_","com.fulcrologic.fulcro.routing.dynamic-routing/target-ready!","component-or-app","com.fulcrologic.fulcro.raw.components.transact_BANG_","G__45011","com.fulcrologic.fulcro.routing.dynamic-routing/router?","com.fulcrologic.fulcro.routing.dynamic-routing/matching-prefix","route-segment","actual-path","matching-segment","p__45012","vec__45013","expected","actual","cljs.core/Keyword","cljs.core/seq","cljs.core.map","a","b","cljs.core/count","com.fulcrologic.fulcro.routing.dynamic-routing/current-route-class","com.fulcrologic.fulcro.raw.components/any->app","G__45017","edn-query-language.core/query->ast","p1__45016#","cljs.core.filter","com.fulcrologic.fulcro.raw.components/class->registry-key","com.fulcrologic.fulcro.raw.components/registry-key->class","com.fulcrologic.fulcro.routing.dynamic-routing/route-target","path","targets","matches","prefix","G__45019","cljs.core.sort_by","cljs.core/reverse","max-length","G__45020","match","p1__45018#","com.fulcrologic.fulcro.routing.dynamic-routing/accepts-route?","p__45023","map__45024","com.fulcrologic.fulcro.routing.dynamic-routing/ast-node-for-route","children","ast-node","p1__45021#","cljs.core/some","p1__45022#","p__45027","map__45028","com.fulcrologic.fulcro.routing.dynamic-routing/ast-node-for-live-router","com.fulcrologic.fulcro.components/class->any","live-router?","p1__45025#","p1__45026#","com.fulcrologic.fulcro.routing.dynamic-routing/apply-route","map__45029","p__45030","map__45031","*after-render*-orig-val__45032","*after-render*-temp-val__45033","*after-render*-orig-val__45034","*after-render*-temp-val__45035","state","cljs.core.swap_BANG_","p__45036","map__45037","com.fulcrologic.fulcro.routing.dynamic-routing/mark-route-pending*","com.fulcrologic.fulcro.routing.dynamic-routing/ready-handler","new-env","com.fulcrologic.fulcro.ui-state-machines/store","com.fulcrologic.fulcro.ui_state_machines.retrieve","com.fulcrologic.fulcro.ui_state_machines.apply_action","target-ready*","com.fulcrologic.fulcro.algorithms.indexing/reindex","com.fulcrologic.fulcro.routing.dynamic-routing/fail-handler","p__45038","map__45039","com.fulcrologic.fulcro.routing.dynamic-routing/route-handler","event-data","map__45040","error-timeout","deferred-timeout","path-segment","immediate?","com.fulcrologic.fulcro.ui-state-machines/activate","com.fulcrologic.fulcro.ui_state_machines.set_timeout","cljs.core.assoc","com.fulcrologic.fulcro.ui-state-machines/register-state-machine!","com.fulcrologic.fulcro.routing.dynamic-routing/RouterStateMachine","cljs.core/identity","G__45042","com.fulcrologic.fulcro.routing.dynamic-routing/proposed-new-path","this-or-app","relative-class-or-instance","new-route","com.fulcrologic.fulcro.routing.dynamic_routing.proposed_new_path","timeouts-and-params","cljs.core/deref","root-query","ast","root","cljs.core.atom","G__45044","map__45045","map__45054","map__45055","matching-prefix","target-ast","G__45056","prefix-length","remaining-path","cljs.core/vec","cljs.core.drop","segment","p__45057","vec__45058","p","k","v","cljs.core.dissoc","target-ident","edn-query-language.core/ident?","cljs.core/contains?","G__45061","cljs.core/conj","cljs.core.vary_meta","cljs.core/assoc","G__45065","com.fulcrologic.fulcro.routing.dynamic-routing/signal-router-leaving","app-or-comp","com.fulcrologic.fulcro.routing.dynamic_routing.signal_router_leaving","new-path","to-signal","to-cancel","G__45067","map__45068","map__45069","node","new-path-remaining","map__45070","new-target","router-ident","active-target","next-router","p1__45062#","cljs.core.not_EQ_","mounted-target-class","p__45071","map__45072","acc","dispatch-key","G__45073","mounted-targets","com.fulcrologic.fulcro.components/class->all","cljs.core/into","cljs.core/rest","components","seq__45074","chunk__45075","count__45076","i__45077","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/next","will-leave-result","p1__45063#","seq__45078","chunk__45079","count__45080","i__45081","t","map__45086","map__45088","G__45087","G__45089","G__45092","com.fulcrologic.fulcro.routing.dynamic-routing/current-route","cls","G__45093","com.fulcrologic.fulcro.application/root-class","com.fulcrologic.fulcro.routing.dynamic_routing.current_route","G__45095","map__45096","map__45098","sm-env","com.fulcrologic.fulcro.ui_state_machines.state_machine_env","p1__45090#","com.fulcrologic.fulcro.routing.dynamic-routing/mounted-targets","p__45099","map__45100","G__45101","com.fulcrologic.fulcro.routing.dynamic-routing/set-force-route-flag!","route-target","com.fulcrologic.fulcro.routing.dynamic_routing.goog$module$goog$object.set","com.fulcrologic.fulcro.routing.dynamic-routing/force-route-flagged?","G__45104","com.fulcrologic.fulcro.routing.dynamic-routing/target-denying-route-changes","relative-class","G__45106","map__45107","map__45109","p1__45102#","rejecting-target","cljs.core/not","com.fulcrologic.fulcro.routing.dynamic_routing.target_denying_route_changes","G__45111","com.fulcrologic.fulcro.routing.dynamic-routing/can-change-route?","com.fulcrologic.fulcro.routing.dynamic-routing/evaluate-relative-path","relative-instance","G__45115","vec__45116","seq__45117","first__45118","vec__45122","seq__45123","first__45124","current-instance","lead-element","remainder","looking-for-router?","cljs.core/empty?","com.fulcrologic.fulcro.components.get_parent","G__45126","com.fulcrologic.fulcro.routing.dynamic-routing/change-route-relative!","com.fulcrologic.fulcro.routing.dynamic_routing.change_route_relative_BANG_","vec__45127","com.fulcrologic.fulcro.raw.components/component?","com.fulcrologic.fulcro.components/react-type","old-route","com.fulcrologic.fulcro.routing.dynamic_routing.can_change_route_QMARK_","route-denied","routing-actions","pessimistic-txn","delayed-targets","G__45131","map__45132","map__45147","map__45148","map__45149","G__45150","p__45151","vec__45152","path-ordered?","show-early?","result__34355__auto__","e__34296__auto__","e45155","completing-action","G__45156","com.fulcrologic.fulcro.components.transact_BANG_","cljs.core.merge","G__45157","G__45158","com.fulcrologic.fulcro.ui-state-machines/get-active-state","com.fulcrologic.fulcro.components/component->state-map","com.fulcrologic.fulcro.ui_state_machines.begin_BANG_","com.fulcrologic.fulcro.ui-state-machines/with-actor-class","*after-render*-orig-val__45159","*after-render*-temp-val__45160","seq__45161","chunk__45162","count__45163","i__45164","action","cljs.core.into","cljs.core.concat","com.fulcrologic.fulcro.routing.dynamic-routing/change-route-relative","com.fulcrologic.fulcro.routing.dynamic-routing/retry-route!","denied-target-instance","relative-root","G__45166","com.fulcrologic.fulcro.routing.dynamic-routing/change-route!","com.fulcrologic.fulcro.routing.dynamic_routing.change_route_BANG_","com.fulcrologic.fulcro.routing.dynamic-routing/change-route","com.fulcrologic.fulcro.routing.dynamic-routing/validate-route-targets","router-instance","seq__45168","chunk__45170","count__45171","i__45172","valid?","p1__45167#","cljs.core/every?","com.fulcrologic.fulcro.routing.dynamic-routing/all-reachable-routers","component-class","map__45175","get-routers","nodes","p__45176","map__45177","get-routers*","com.fulcrologic.fulcro.routing.dynamic-routing/initialize!","tx","cljs.core.mapv","G__45178","com.fulcrologic.fulcro.ui-state-machines/begin","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.routing.dynamic-routing/into-path","seq45179","G__45180","G__45181","self__5754__auto__","TargetClass","path-args","nargs","G__45182","com.fulcrologic.fulcro.raw.components/component-options","static-elements","cljs.core.take","com.fulcrologic.fulcro.routing.dynamic-routing/subpath","seq45183","G__45184","cljs.core.apply","com.fulcrologic.fulcro.routing.dynamic-routing/path-to","seq45188","self__5755__auto__","targets-and-params","segments","p1__45185#","cljs.core.partition_by","cljs.core/fn?","com.fulcrologic.fulcro.raw.components/component-class?","cljs.core/map?","p1__45186#","cljs.core.mapcat","i","p__45189","vec__45190","classes","p1__45187#","cljs.core/butlast","cljs.core/last","cljs.core.partition_all","com.fulcrologic.fulcro.routing.dynamic-routing/resolve-path-components","StartingClass","RouteTarget","query","root-node","zipper","p1__45193#","clojure.zip/zipper","n","cljs.core/iterate","clojure.zip/next","cljs.core.drop_while","map__45194","clojure.zip/node","clojure.zip/end?","found?","G__45195","clojure.zip/path","G__45198","com.fulcrologic.fulcro.routing.dynamic-routing/resolve-path","resolved-components","base-path","p1__45196#","ele","com.fulcrologic.fulcro.routing.dynamic_routing.resolve_path","com.fulcrologic.fulcro.routing.dynamic-routing/resolve-target","G__45200","map__45201","map__45205","map__45206","G__45207","p__45221","map__45222","parent-component","ast-nodes","G__45223","G__45224","G__45225","G__45226","G__45227","com.fulcrologic.fulcro.components/get-ident","active-ast-node","p__45228","map__45229","new-parent","active-routes*","subpath","p__45230","map__45231","p__45232","map__45233","G__45235","com.fulcrologic.fulcro.routing.dynamic-routing/active-routes","com.fulcrologic.fulcro.routing.dynamic_routing.active_routes","com.fulcrologic.fulcro.application/app-root","starting-from","map__45236","com.fulcrologic.fulcro.components.get_query","cljs.core/List"],"sourcesContent":["(ns com.fulcrologic.fulcro.routing.dynamic-routing\n  \"A router that uses Fulcro dynamic queries to optimize query performance on rendering and provides a number of useful\n  features such as easy composition, control over route targeting, on-screen component vetoes of routing requests, etc.\n\n  NOTE: This router is *not* concerned with HTML5 history events or URL management. This router is intended to be usable\n  in server-side rendering, React Native, and anywhere else Fulcro might be used. Therefore it is not tied to a particular\n  rendering platform's idea of location management (i.e. URLs).\n\n  The structure of the route composition (and its representation as a sequence of string path components) is intended to\n  be easy to integrate with HTML5 history and URL control.\"\n  #?(:cljs (:require-macros [com.fulcrologic.fulcro.routing.dynamic-routing]))\n  (:require\n    #?(:cljs [goog.object :as gobj])\n    [clojure.zip :as zip]\n    [com.fulcrologic.guardrails.core :refer [>fdef => ?]]\n    [com.fulcrologic.fulcro.ui-state-machines :as uism :refer [defstatemachine]]\n    [com.fulcrologic.fulcro.components :as comp]\n    [com.fulcrologic.fulcro.raw.components :as rc]\n    [com.fulcrologic.fulcro.application :as app]\n    [com.fulcrologic.fulcro.mutations :refer [defmutation]]\n    [edn-query-language.core :as eql]\n    [taoensso.timbre :as log]\n    [clojure.spec.alpha :as s]\n    #?(:clj [cljs.analyzer :as ana])\n    [com.fulcrologic.fulcro.algorithms.indexing :as indexing]))\n\n(def ^:dynamic *target-class*\n  \"INTERNAL USE ONLY. Not guaranteed to be available at runtime in production builds. This is used to aid in giving\n   development-time warnings/errors.\n\n   Class of the routing target component, available in the notifications fns\n   (:will-enter, :route-cancelled, :will-leave)\"\n  nil)\n\n(declare route-immediate)\n\n(defn route-segment\n  \"Returns a vector that describes the sub-path that a given route target represents. String elements represent\n  explicit path elements, and keywords represent variable values (which are always pulled as strings).\"\n  [class]\n  (let [result (rc/component-options class :route-segment)]\n    (when (and #?(:clj true :cljs goog.DEBUG)\n            (not (or (nil? result) (vector? result))))\n      (log/error \"Route segment should be a vector!\"))\n    result))\n\n(defn get-route-cancelled\n  \"Returns the function that should be called if this target was in a deferred state and a different routing choice was made. Is given the same route parameters that were sent to `will-enter`.\"\n  [class]\n  (rc/component-options class :route-cancelled))\n\n(defn route-cancelled\n  \"Universal CLJC version of route-cancelled.  Don't use the protocol method in CLJ.\"\n  [class route-params]\n  (when-let [f (get-route-cancelled class)]\n    (binding [*target-class* class]\n      (f route-params))))\n\n(defn get-will-enter\n  \"Returns the function that is called before a route target is activated (if the route segment of interest has changed and the\n  target of the result is this target).  MUST return (r/route-immediate ident) or (r/route-deferred ident) to indicate\n  what ident should be used in app state to connect the router's join.  If deferred, the router must cause a call to\n  the r/target-ready mutation (or use the target-ready* mutation helper) with a {:target ident} parameter to indicate\n  that the route target is loaded and ready for display.\n\n  `params` will be a map from any keywords found in `route-segment` to the string value of that path element.\n\n  WARNING: This method MUST be side-effect free.\"\n  [class]\n  (if-let [will-enter (rc/component-options class :will-enter)]\n    will-enter\n    (let [ident (rc/get-ident class {})]\n      (when-not ident (log/error \"Component must have an ident for routing to work properly:\" (rc/component-name class) \"See https://book.fulcrologic.com/#err-dr-comp-needs-ident\"))\n      (fn [_ _] (route-immediate ident)))))\n\n(defn will-enter\n  \"Universal CLJC version of will-enter.\"\n  [class app params]\n  (when-let [will-enter (get-will-enter class)]\n    (binding [*target-class* class]\n      (will-enter app params))))\n\n(defn route-target? [component] (boolean (rc/component-options component :route-segment)))\n\n(defn get-will-leave\n  \"Returns the function of a route target to be called with\n  the current component and props. If it returns `true` then the routing operation will continue.  If it returns `false`\n  then whatever new route was requested will be completely abandoned. If this component has a `allow-route-change?`\n  then the return value of will-leave will be ignored.\"\n  [this]\n  (or (rc/component-options this :will-leave) (constantly true)))\n\n(defn will-leave [c props]\n  (when-let [f (get-will-leave c)]\n    (binding [*target-class* (rc/isoget c :type)]\n      (f c props))))\n\n(defn get-allow-route-change?\n  \"Returns the function of a route target to be called with the current component and props.\n   If it returns `true` then the routing operation can continue.  If it returns `false`\n   then whatever new route was requested will be completely abandoned. This handler MUST NOT side-effect, and\n   may be called multiple times on a single route request.\"\n  [this]\n  (or\n    (rc/component-options this :allow-route-change?)\n    (when-let [will-leave (rc/component-options this :will-leave)]\n      (log/warn \"DEPRECATED USE OF `:will-leave` to check for allowable routing. You should add :allow-route-change? to: \" (rc/component-name this) \"See https://book.fulcrologic.com/#warn-routing-will-leave-deprecated\")\n      (fn [] (will-leave this (rc/props this))))\n    (constantly true)))\n\n(defn allow-route-change? [c]\n  (try\n    (when-let [f (get-allow-route-change? c)]\n      (binding [*target-class* (rc/isoget c :type)]\n        (f c)))\n    (catch #?(:clj Exception :cljs :default) e\n      (log/error \"Cannot evaluate route change. Assuming ok. Exception message: \" (ex-message e) \"See https://book.fulcrologic.com/#err-dr-cant-eval-route-chng\")\n      true)))\n\n(defn route-lifecycle? [component] (boolean (rc/component-options component :will-leave)))\n\n(defn get-targets\n  \"Returns a set of classes to which this router routes.\"\n  [router]\n  (set (rc/component-options router :router-targets)))\n\n(defn- ident-matches-expectation? [[expected-table maybe-expected-id] [table id]]\n  ;; NOTE: If the `id` of the ident is hardcoded then maybe-expected-id will be set,\n  ;; but if it depends on props then it will be nil\n  (and (= expected-table table)\n    (or (nil? maybe-expected-id) (= maybe-expected-id id))))\n\n(defn- check-ident-matches-expectation? [fn-name ident]\n  (when (and #?(:clj false :cljs goog.DEBUG)\n          *target-class*\n          (not (ident-matches-expectation? (rc/ident *target-class* {}) ident)))\n    (log/error fn-name \" was invoked with the ident \" ident\n      \" which doesn't seem to match the ident of the wrapping component (class \"\n      *target-class* \" , ident [\"\n      (first (rc/ident *target-class* {})) \" ...]) See https://book.fulcrologic.com/#err-dr-ident-mismatch\")))\n\n(defn route-immediate\n  \"Used as a return value from `will-enter`. Instructs the routing system that you would like this target to be\n   routed to as soon as possible. UI switching defaults to depth-first to prevent flicker.\"\n  [ident]\n  (check-ident-matches-expectation? \"route-immediate\" ident)\n  (with-meta ident {:immediate true}))\n\n(defn route-deferred\n  \"Used as a return value from `will-enter`. Instructs the router to run the `completion-fn`. The completion function\n   *must* use the mutation `target-ready` or function `target-ready!` to indicate when it is ready for the target to\n   appear on-screen.\"\n  [ident completion-fn]\n  (check-ident-matches-expectation? \"route-deferred\" ident)\n  (with-meta ident {:immediate false\n                    :fn        completion-fn}))\n(defn immediate? [ident] (some-> ident meta :immediate))\n\n(defn route-with-path-ordered-transaction\n  \"Used as a return value from `will-enter`. Instructs the routing system to execute the `txn` in *routing path order*,\n   and optionally couples these operations into a single transaction. This can be used in cases where you need the\n   side-effects (potentially full-stack) to complete for a parent target before those of a nested target.\n\n   The `options` can contain:\n\n   * `:optimistic?`  (default false) - When true, don't wait for this transaction to (full-stack) complete before starting\n     child target effects.\n   * `:route-immediate?` (default false) - When true, apply the UI routing immediately instead of waiting for the transaction\n     to finish. Of course the UI of the target should then be willing to tolerate the lack of any full-stack result.\n   * `:show-early?` - (default false) - When true each transaction that completes will cause that target to appear. When\n    false the target won't appear until after all children have completed their non-optimistic path-based transactions.\n  \"\n  ([ident txn] (route-with-path-ordered-transaction ident txn {}))\n  ([ident txn {:keys [optimistic? route-immediate?] :as options}]\n   (let [optimistic?      (if (some? optimistic?) optimistic? false)\n         route-immediate? (if (some? route-immediate?) route-immediate? false)]\n     (with-meta ident {:path-ordered? true\n                       :immediate     route-immediate?\n                       :txn           txn\n                       :optimistic?   optimistic?}))))\n\n(defn- apply-route* [state-map {:keys [router target]}]\n  (let [router-class (-> router meta :component)\n        router-id    (second router)\n        target-class (-> target meta :component)]\n    (log/debug \"Applying route ident\" target \"to router\" router-id)\n    (when (nil? router-class)\n      (log/error \"apply-route* was called without a proper :router argument. See https://book.fulcrologic.com/#err-dr-apply-route-lacks-router\"))\n    (when (nil? target-class)\n      (log/error \"apply-route* for router \" router-class \"was given a target that did not have a component. \"\n        \"Did you remember to call route-deferred or route-immediate? See https://book.fulcrologic.com/#err-dr-apply-route-no-component\"))\n    (-> state-map\n      (assoc-in (conj router ::current-route) target)\n      (update-in router dissoc ::pending-route)\n      (rc/set-query* router-class {:query [::id [::uism/asm-id router-id] {::current-route (rc/get-query target-class state-map)}]}))))\n\n(defn router-for-pending-target [state-map target]\n  (let [routers   (some-> state-map ::id vals)\n        router-id (reduce (fn [_ r]\n                            (when (and #?(:clj true :cljs goog.DEBUG) (nil? (::id r)))\n                              (log/error \"There is a router in state that is missing an ID. This indicates that\"\n                                \"you forgot to compose it into your initial state! It will fail to operate properly. See https://book.fulcrologic.com/#err-dr-router-missing-id\"))\n                            (when (= target (some-> r ::pending-route :target))\n                              (reduced (::id r))))\n                    nil\n                    routers)]\n    router-id))\n\n(defmutation target-ready\n  \"Mutation: Indicate that a target is ready.\"\n  [{:keys [target]}]\n  (action [{:keys [app]}]\n    (let [state-map (app/current-state app)\n          router-id (router-for-pending-target state-map target)]\n      (if router-id\n        (do\n          (log/debug \"Router\" router-id \"notified that pending route is ready.\")\n          (when (and #?(:clj false :cljs goog.DEBUG) (nil? (get-in state-map target)))\n            (log/error `target-ready \"should route to\" target \"but there is no data in the DB for the ident.\"\n              \"Perhaps you supplied a wrong ident? See https://book.fulcrologic.com/#err-dr-target-ready-missing-data\"))\n          (uism/trigger! app router-id :ready!))\n        (log/error \"dr/target-ready! was called but there was no router waiting for the target listed: \" target\n          \"This could mean you sent one ident, and indicated ready on another. See https://book.fulcrologic.com/#err-dr-target-ready-no-router-waiting\"))))\n  (refresh [_] [::current-route]))\n\n(defn target-ready!\n  \"Indicate a target is ready.  Safe to use from within mutations.\n\n  target - The ident that was originally listed as a deferred target.\"\n  [component-or-app target]\n  (rc/transact! component-or-app [(target-ready {:target target})]))\n\n(defn router? [component] (boolean (rc/component-options component :router-targets)))\n\n(defn matching-prefix\n  \"Returns the elements of actual-path that match the route-segment definition.\"\n  [route-segment actual-path]\n  (let [matching-segment (reduce\n                           (fn [result [expected actual]]\n                             (cond\n                               (and (string? expected) (= expected actual))\n                               (conj result actual)\n\n                               (and (keyword? expected) (seq (str actual)))\n                               (conj result (str actual))\n\n                               :otherwise result))\n                           []\n                           (map (fn [a b] [a b]) route-segment actual-path))]\n    (when (= (count matching-segment) (count route-segment))\n      matching-segment)))\n\n(defn current-route-class\n  \"Get the class of the component that is currently being routed to.\"\n  [this]\n  (let [state-map (app/current-state (rc/any->app this))\n        class     (some->> (rc/get-query this state-map) eql/query->ast :children\n                    (filter #(= ::current-route (:key %))) first :component)\n        ;; Hot code reload support to avoid getting the cached class from old metadata\n        class     (if #?(:cljs goog.DEBUG :clj false)\n                    (-> class rc/class->registry-key rc/registry-key->class)\n                    class)]\n    class))\n\n(defn route-target\n  \"Given a router class and a path segment, returns the class of *that router's* target that accepts the given URI path,\n  which is a vector of (string) URI components.\n\n  Returns nil if there is no target that accepts the path, or a map containing:\n\n  {:target class\n   :matching-prefix prefix}\n\n  where `class` is the component class that accepts the path (the target, NOT the router), and `matching-prefix` is the\n  portion of the path that is accepted by that class.\n\n  NOTE: If more than one target matches, then the target with the longest match will be returned. A warning will be\n  printed if more than one match of equal length is found.\n  \"\n  [router-class path]\n  (when (and router-class (router? router-class))\n    (let [targets    (get-targets router-class)\n          matches    (->> (reduce (fn [result target-class]\n                                    (let [prefix (and target-class (route-target? target-class)\n                                                   (some-> target-class (route-segment) (matching-prefix path)))]\n                                      (if (and prefix (seq prefix))\n                                        (conj result {:length          (count prefix)\n                                                      :matching-prefix prefix\n                                                      :target          target-class})\n                                        result))) [] targets)\n                       (sort-by :length)\n                       reverse)\n          max-length (some-> matches first :length)\n          match      (filter #(= max-length (:length %)) matches)]\n      (when (second match)\n        (log/warn \"More than one route target matches\" path \"See https://book.fulcrologic.com/#warn-routing-multiple-target-matches\"))\n      (first match))))\n\n(defn accepts-route?\n  \"Returns true if the given component is a router that manages a route target that will accept the given path.\"\n  [component path]\n  (boolean (route-target component path)))\n\n(defn ast-node-for-route\n  \"Returns the AST node for a query that represents the router that has a target that can accept the given path. This is a breadth-first\n  search.\n\n  ast - A query AST node\n  path - A vector of the current URI segments.\n\n  Returns an AST node or nil if none is found.\"\n  [{:keys [component children] :as ast-node} path]\n  (or\n    (and (accepts-route? component path) ast-node)\n    (some #(and (accepts-route? (:component %) path) %) children)\n    (some #(ast-node-for-route % path) children)))\n\n(defn ast-node-for-live-router\n  \"Returns the AST node for a query that represents the closest \\\"live\\\" (on-screen) router\n\n  ast - A query AST node\n\n  Returns an AST node or nil if none is found.\"\n  [app {:keys [component children] :as ast-node}]\n  (letfn [(live-router? [c] (and (router? c) (boolean (comp/class->any app c))))]\n    (or\n      (and (live-router? component) ast-node)\n      (some #(and (live-router? (:component %)) %) children)\n      (some #(ast-node-for-live-router app %) children))))\n\n\n(defmutation apply-route\n  \"Mutation: Indicate that a given route is ready and should show the result.\n\n  router - The ident of the router, with metadata :component that is the class of the router.\n  target - The ident of the target route, with metadata :component that is the class of the target.\"\n  [{:keys [router target] :as params}]\n  (action [{:keys [app state]}]\n    (swap! state apply-route* params)))\n\n(defn mark-route-pending* [state-map {:keys [router target] :as params}]\n  (assoc-in state-map (conj router ::pending-route) params))\n\n(letfn [(target-ready*\n          [state-map target]\n          (let [router-id (router-for-pending-target state-map target)]\n            (if router-id\n              (apply-route* state-map (get-in state-map [::id router-id ::pending-route]))\n              state-map)))]\n  (defn ready-handler [env]\n    (let [new-env (-> env\n                    (uism/store :path-segment (uism/retrieve env :pending-path-segment))\n                    (uism/store :pending-path-segment [])\n                    (uism/apply-action target-ready* (uism/retrieve env :target)))\n          app     (::uism/app env)]\n      (when app\n        (rc/transact! app [(indexing/reindex)]))\n      new-env)))\n\n(defn fail-handler [env] env)\n\n(defn route-handler [{::uism/keys [app event-data] :as env}]\n  (let [{:keys [router target error-timeout deferred-timeout path-segment] :or {error-timeout 5000 deferred-timeout 20}} event-data\n        immediate? (immediate? target)]\n    (-> (if immediate?\n          (let [new-env (-> env\n                          (uism/store :path-segment path-segment)\n                          (uism/apply-action apply-route* event-data)\n                          (uism/activate :routed))]\n            (when app\n              (rc/transact! app [(indexing/reindex)]))\n            new-env)\n          (-> env\n            (uism/store :pending-path-segment path-segment)\n            (uism/apply-action mark-route-pending* event-data)\n            (uism/set-timeout :error-timer :timeout! {} error-timeout #{:ready! :route!})\n            (uism/set-timeout :delay-timer :waiting! {} deferred-timeout #{:ready! :route!})\n            (uism/activate :deferred)))\n      (uism/store :target target))))\n\n(defstatemachine RouterStateMachine\n  {::uism/actors\n   #{:router}\n\n   ::uism/aliases\n   {:current-route [:router ::current-route]\n    :state         [:router ::current-state]}\n\n   ::uism/states\n   {:initial  {::uism/handler route-handler}\n\n    :deferred {::uism/events\n               {:waiting! {::uism/target-state :pending}\n                :route!   {::uism/handler route-handler}\n                :ready!   {::uism/target-state :routed\n                           ::uism/handler      ready-handler}\n                :timeout! {::uism/target-state :failed\n                           ::uism/handler      fail-handler}}}\n\n    :pending  {::uism/events\n               {:waiting! {::uism/target-state :pending}\n                :route!   {::uism/handler route-handler}\n                :ready!   {::uism/target-state :routed\n                           ::uism/handler      ready-handler}\n                :timeout! {::uism/target-state :failed\n                           ::uism/handler      fail-handler}}}\n\n    ;; failed may potentially resolve (just very late), so it must accept ready! events\n    :failed   {::uism/events\n               {:route! {::uism/handler route-handler}\n                :ready! {::uism/target-state :routed\n                         ::uism/handler      ready-handler}}}\n\n    :routed   {::uism/events {:waiting! {::uism/handler identity} ; in case we fail to cancel timer\n                              :timeout! {::uism/handler identity}\n                              :route!   {::uism/handler route-handler}}}}})\n\n;; TODO: This algorithm is repeated in more than one place in slightly different forms...refactor it.\n(defn proposed-new-path\n  \"Internal algorithm: Returns a sequence of idents of the targets that the `new-route` goes through by analyzing the current\n  application query and state.\"\n  ([this-or-app relative-class-or-instance new-route]\n   (proposed-new-path this-or-app relative-class-or-instance new-route {}))\n  ([this-or-app relative-class-or-instance new-route timeouts-and-params]\n   (let [app        (rc/any->app this-or-app)\n         state-map  (app/current-state app)\n         root-query (rc/get-query relative-class-or-instance state-map)\n         ast        (eql/query->ast root-query)\n         root       (ast-node-for-route ast new-route)\n         result     (atom [])]\n     (loop [{:keys [component]} root path new-route]\n       (when (and component (router? component))\n         (let [{:keys [target matching-prefix]} (route-target component path)\n               target-ast     (some-> target (rc/get-query state-map) eql/query->ast)\n               prefix-length  (count matching-prefix)\n               remaining-path (vec (drop prefix-length path))\n               segment        (route-segment target)\n               params         (reduce\n                                (fn [p [k v]] (if (keyword? k) (assoc p k v) p))\n                                (dissoc timeouts-and-params :error-timeout :deferred-timeout)\n                                (map (fn [a b] [a b]) segment matching-prefix))\n               target-ident   (will-enter target app params)]\n           (when (or (not (eql/ident? target-ident)) (nil? (second target-ident)))\n             (log/error \"will-enter for router target\" (rc/component-name target) \"did not return a valid ident. Instead it returned: \" target-ident \"See https://book.fulcrologic.com/#err-dr-will-enter-invalid-ident\"))\n           (when (and (eql/ident? target-ident)\n                   (not (contains? (some-> target-ident meta) :immediate)))\n             (log/error \"will-enter for router target\" (rc/component-name target) \"did not wrap the ident in route-immediate, route-deferred, or route-with-path-ordered-transaction. See https://book.fulcrologic.com/#err-dr-will-enter-missing-metadata\"))\n           (when (vector? target-ident)\n             (swap! result conj (vary-meta target-ident assoc :component target :params params)))\n           (when (seq remaining-path)\n             (recur (ast-node-for-route target-ast remaining-path) remaining-path)))))\n     @result)))\n\n(defn signal-router-leaving\n  \"Tell active routers that they are about to leave the screen. Returns false if any of them deny the route change.\"\n  ([app-or-comp relative-class-or-instance new-route]\n   (signal-router-leaving app-or-comp relative-class-or-instance new-route {}))\n  ([app-or-comp relative-class-or-instance new-route timeouts-and-params]\n   (let [new-path   (proposed-new-path app-or-comp relative-class-or-instance new-route timeouts-and-params)\n         app        (rc/any->app app-or-comp)\n         state-map  (app/current-state app)\n         router     relative-class-or-instance\n         root-query (rc/get-query router state-map)\n         ast        (eql/query->ast root-query)\n         root       (ast-node-for-live-router app ast)\n         to-signal  (atom [])\n         to-cancel  (atom [])\n         _          (loop [{:keys [component children] :as node} root new-path-remaining new-path]\n                      (when (and component (router? component))\n                        (let [new-target    (first new-path-remaining)\n                              router-ident  (rc/get-ident component {})\n                              active-target (get-in state-map (conj router-ident ::current-route))\n                              {:keys [target]} (get-in state-map (conj router-ident ::pending-route))\n                              next-router   (some #(ast-node-for-live-router app %) children)]\n                          (when (eql/ident? target)\n                            (swap! to-cancel conj target))\n                          (when (and (not= new-target active-target) (vector? active-target))\n                            (let [mounted-target-class (reduce (fn [acc {:keys [dispatch-key component]}]\n                                                                 (when (= ::current-route dispatch-key)\n                                                                   (reduced component)))\n                                                         nil\n                                                         (some-> component (rc/get-query state-map)\n                                                           eql/query->ast :children))\n                                  mounted-targets      (comp/class->all app mounted-target-class)]\n                              (when (seq mounted-targets)\n                                (swap! to-signal into mounted-targets))))\n                          (when next-router\n                            (recur next-router (rest new-path-remaining))))))\n         components (reverse @to-signal)\n         result     (atom true)]\n     (doseq [c components]\n       (let [will-leave-result (will-leave c (rc/props c))]\n         (swap! result #(and % will-leave-result))))\n     (when @result\n       (doseq [t @to-cancel]\n         (let [{:keys [component params]} (some-> t meta)]\n           (route-cancelled component params))))\n     @result)))\n\n(defn current-route\n  \"Returns the current active route, starting from the relative Fulcro class or instance.\n\n  Any component using this as a basis for rendering will need to add the following to their query to\n  ensure the props of that component change on route changes:\n\n  ```\n  [::uism/asm-id fq-router-kw]\n  ```\n\n  where `fq-router-kw` is a keyword that has the exact namespace and name of the router you're interested in. If you want\n  to just over-render you can use a quoted `_` instead.\n\n  NOTE: This function is primarily meant to be used in mutation implementations or with global routing.\n  It is not reliable to use this function during render because it relies on the router being mounted (and render gets\n  called in order to determine what to render). If you want to know the current state of a particular\n  router you should query for it's ASM as indicated above.\n  \"\n  ([this-or-app]\n   (if-let [cls (some-> this-or-app rc/any->app app/root-class)]\n     (current-route this-or-app cls)\n     []))\n  ([this-or-app relative-class-or-instance]\n   (let [app        (rc/any->app this-or-app)\n         state-map  (app/current-state app)\n         router     relative-class-or-instance\n         root-query (rc/get-query router state-map)\n         ast        (eql/query->ast root-query)\n         root       (or (ast-node-for-live-router app ast)\n                      (-> ast :children first))\n         result     (atom [])]\n     (loop [{:keys [component] :as node} root]\n       (when (and component (router? component))\n         (let [router-ident (rc/get-ident component {})\n               router-id    (-> router-ident second)\n               sm-env       (uism/state-machine-env state-map nil router-id :none {})\n               path-segment (uism/retrieve sm-env :path-segment)\n               next-router  (some #(ast-node-for-live-router app %) (:children node))]\n           (when (seq path-segment)\n             (swap! result into path-segment))\n           (when next-router\n             (recur next-router)))))\n     @result)))\n\n(defn- mounted-targets [app router-class]\n  (let [state-map            (app/current-state app)\n        mounted-target-class (reduce (fn [acc {:keys [dispatch-key component]}]\n                                       (when (= ::current-route dispatch-key)\n                                         (reduced component)))\n                               nil\n                               (some-> router-class (rc/get-query state-map)\n                                 eql/query->ast :children))]\n    (comp/class->all app mounted-target-class)))\n\n(defn- set-force-route-flag! [route-target]\n  #?(:cljs (gobj/set route-target \"fulcro$routing$force_route\" true)))\n\n(defn- force-route-flagged?\n  \"returns true if the given route target's allow-route-change? should be ignored.\"\n  [route-target]\n  (rc/isoget route-target \"fulcro$routing$force_route\"))\n\n(defn target-denying-route-changes\n  \"This function will return the first mounted instance of a route target that is currently indicating it would\n  deny a route change. If a `relative-class` is given then it only looks for targets that would deny a change within\n  that router's subtree.\"\n  ([this-or-app relative-class]\n   (let [app        (rc/any->app this-or-app)\n         state-map  (app/current-state app)\n         root-query (rc/get-query relative-class state-map)\n         ast        (eql/query->ast root-query)\n         root       (or (ast-node-for-live-router app ast)\n                      (-> ast :children first))]\n     (loop [{router-class :component\n             :keys        [children]} root]\n       (when (and router-class (router? router-class))\n         (let [router-ident     (rc/get-ident router-class {})\n               active-target    (get-in state-map (conj router-ident ::current-route))\n               next-router      (some #(ast-node-for-live-router app %) children)\n               rejecting-target (when (vector? active-target)\n                                  (some (fn [c] (when (and\n                                                        (false? (allow-route-change? c))\n                                                        (not (force-route-flagged? c))) c)) (mounted-targets app router-class)))]\n           (cond\n             rejecting-target rejecting-target\n             next-router (recur next-router)))))))\n  ([this-or-app]\n   (let [app    (rc/any->app this-or-app)\n         router (app/root-class app)]\n     (target-denying-route-changes app router))))\n\n(defn can-change-route?\n  \"Returns true if the active on-screen targets indicate they will allow navigation.\n\n  NOTE: If your route targets have an `:allow-route-change?`, then that will be used to determine if the route can\n  be abandoned; otherwise `:will-leave` will be called to answer the question; however, this USE of `will-leave`\n  is DEPRECATED (though the hook is NOT because it serves another purpose). If you side-effect in `:will-leave` this could cause strange\n  behavior throughout the application.  It is recommended that your targets implement `:allow-route-change?` if they need\n  to prevent routing, and only leverage `:will-leave` to do things like cancel in-progress loads.\"\n  ([this-or-app] (nil? (target-denying-route-changes this-or-app)))\n  ([this-or-app relative-class] (nil? (target-denying-route-changes this-or-app relative-class))))\n\n(defn evaluate-relative-path\n  \"Takes an on-screen *instance* of a react element and a new route (vector of strings) and returns a vector containing\n   either the original arguments, or an evaluation of relative navigation up the live routing tree.\n\n   If `new-route` starts with `:..` (any number of times) then this function finds (and returns) the parent *router*\n   and the new route stripped of `:..` prefix.\n\n   For example, say you were in a target instance that has a parent router, which in turn has a parent router called\n   `SomeRouter`. Then:\n\n   ```\n   (dr/evaluate-relative-path this [:.. :.. \\\"some-target\\\"])\n   => [SomeRouter [\\\"some-target\\\"]]\n   ```\n\n   This function does *not* work on classes. It is meant for live evaluation of on-screen instances to enable relative\n   routing based on the actual on-screen route targets.\n\n   CAN return `nil` for the router if no such parent is found.\n\n   Returns unmodified input argument if `new-route` does not begin with `:..`.\n   \"\n  [relative-instance new-route]\n  (loop [current-instance    relative-instance\n         [lead-element & remainder :as path] new-route\n         looking-for-router? ^Boolean (= :.. lead-element)]\n    (cond\n      (or (nil? current-instance) (empty? path))\n      [current-instance path]\n\n      (and looking-for-router? (router? current-instance))\n      (recur current-instance (vec remainder) false)\n\n      looking-for-router?\n      (recur (comp/get-parent current-instance) path true)\n\n      (= :.. lead-element)\n      #_=> (recur (comp/get-parent current-instance) path true)\n\n      :else\n      [current-instance path])))\n\n(defn change-route-relative!\n  \"Change the route, starting at the given Fulcro class or instance (scanning for the first router from there).  `new-route` is a vector\n  of string components to pass through to the nearest child router as the new path. The first argument is any live component\n  or the app.  The `timeouts-and-params` are as in `change-route`.\n\n  When possible (i.e. no circular references to components) you can maintain better code navigation by\n  generating `new-route` via `path-to`.  This will allow readers of your code to quickly jump to the actual\n  components that implement the targets when reading the code.\n\n  You may include the special keyword `:..` any number of times at the beginning of `new-route` to indicate the\n  parent(s) of `relative-class-or-instance`, which allows you to do relative routing to a sibling.\n\n  ```\n  (dr/change-route-relative this this [:.. \\\"sibling-pattern\\\"])\n  ```\n\n  Returns one of:\n\n  `:already-there` - The old and new route are the same, and there was no request to force an idempotent routing operation.\n  `:invalid` - The new route didn't evaluate to a valid location\n  `:denied` - One or more on-screen targets refused to allow the routing operation\n  `:routing` - The routing operation is in progress, but deferred operations may still delay the route becoming visible.\n  \"\n  ([this-or-app relative-class-or-instance new-route]\n   (change-route-relative! this-or-app relative-class-or-instance new-route {}))\n  ([app-or-comp relative-class-or-instance new-route timeouts-and-params]\n   (let [[relative-class-or-instance new-route] (evaluate-relative-path relative-class-or-instance new-route)\n         relative-class (if (rc/component? relative-class-or-instance)\n                          (comp/react-type relative-class-or-instance)\n                          relative-class-or-instance)\n         old-route      (current-route app-or-comp relative-class)\n         new-path       (proposed-new-path app-or-comp relative-class new-route timeouts-and-params)]\n     (cond\n       (and (= old-route new-route) (not (::force? timeouts-and-params)))\n       (do\n         (log/debug \"Request to change route, but path is the current route. Ignoring change request.\")\n         :already-there)\n\n       (and #?(:clj true :cljs goog.DEBUG) (not (seq new-path)))\n       (do\n         (log/error \"Could not find route targets for new-route\" new-route \"See https://book.fulcrologic.com/#err-dr-new-route-target-not-found\")\n         :invalid)\n\n       (not (can-change-route? app-or-comp relative-class))\n       (let [app          (rc/any->app app-or-comp)\n             target       (target-denying-route-changes app)\n             route-denied (rc/component-options target :route-denied)]\n         (log/debug \"Route request denied by on-screen target\" target \". Calling component's :route-denied (if defined).\")\n         (when route-denied\n           (route-denied target relative-class-or-instance new-route))\n         :denied)\n\n       :otherwise\n       (do\n         (signal-router-leaving app-or-comp relative-class-or-instance new-route timeouts-and-params)\n         (let [app             (rc/any->app app-or-comp)\n               state-map       (app/current-state app)\n               router          relative-class-or-instance\n               root-query      (rc/get-query router state-map)\n               ast             (eql/query->ast root-query)\n               root            (ast-node-for-route ast new-route)\n               routing-actions (atom (list))\n               pessimistic-txn (atom [])\n               delayed-targets (atom [])]\n           (loop [{:keys [component]} root path new-route]\n             (when (and component (router? component))\n               (let [{:keys [target matching-prefix]} (route-target component path)\n                     target-ast        (some-> target (rc/get-query state-map) eql/query->ast)\n                     prefix-length     (count matching-prefix)\n                     remaining-path    (vec (drop prefix-length path))\n                     segment           (route-segment target)\n                     params            (reduce\n                                         (fn [p [k v]] (if (keyword? k) (assoc p k v) p))\n                                         (dissoc timeouts-and-params :error-timeout :deferred-timeout)\n                                         (map (fn [a b] [a b]) segment matching-prefix))\n                     router-ident      (rc/get-ident component {})\n                     router-id         (-> router-ident second)\n                     target-ident      (will-enter target app params)\n                     {:keys [path-ordered?\n                             txn\n                             show-early?\n                             optimistic?]} (log/spy :info (meta target-ident))\n                     completing-action (or\n                                         (some-> target-ident meta :fn)\n                                         (and optimistic? (seq txn) #(comp/transact! app txn))\n                                         (constantly true))\n                     event-data        (merge\n                                         {:error-timeout 5000 :deferred-timeout 20}\n                                         timeouts-and-params\n                                         {:path-segment matching-prefix\n                                          :router       (vary-meta router-ident assoc :component component)\n                                          :target       (vary-meta target-ident assoc :component target :params params)})]\n                 (when (and path-ordered? (seq txn) (not optimistic?))\n                   (swap! pessimistic-txn into txn)\n                   (if show-early?\n                     (swap! pessimistic-txn conj (target-ready {:target target-ident}))\n                     (swap! delayed-targets conj (target-ready {:target target-ident}))))\n                 ;; Route instructions queued into a list (which will reverse their order in the doseq below)\n                 (swap! routing-actions conj\n                   #(do\n                      (if-not (uism/get-active-state app router-id)\n                        (do\n                          (let [state-map (comp/component->state-map app-or-comp)]\n                            (when-not (-> state-map ::id (get router-id))\n                              (log/error \"You are routing to a router \" router-id \"whose state was not composed into the app from root. Please check your :initial-state. See https://book.fulcrologic.com/#err-dr-router-state-missing\")))\n                          (uism/begin! app-or-comp RouterStateMachine router-id\n                            {:router (uism/with-actor-class router-ident component)}\n                            event-data))\n                        (uism/trigger! app router-id :route! event-data))\n                      ;; make sure any transactions submitted from the completing action wait for a render of the state machine's\n                      ;; startup or route effects before running.\n                      (binding [rc/*after-render* true]\n                        (completing-action))))\n                 (when (seq remaining-path)\n                   (recur (ast-node-for-route target-ast remaining-path) remaining-path)))))\n           ;; Normal route instructions are sent depth first to prevent flicker\n           (doseq [action @routing-actions]\n             (action))\n           (when (or (seq @pessimistic-txn) (seq @delayed-targets))\n             (log/info \"Running pessimistic transaction\" @pessimistic-txn \"with delayed targets\" @delayed-targets)\n             (comp/transact! app (into [] (concat @pessimistic-txn (reverse @delayed-targets)))\n               {:optimistic? false})))\n         :routing)))))\n\n(def change-route-relative \"DEPRECATED NAME: Use change-route-relative!\" change-route-relative!)\n\n(defn retry-route!\n  \"Retry a route that the receiving component just denied, and ignore this target's answer. All other targets will still\n  be asked. This is primarily used when you want to be able to use js/confirm in a component to ask the user if\n  they \\\"really mean to navigate away\\\". You MUST pass the arguments that `:route-denied` received\n  or you can easily cause an infinite loop. Other on-screen targets can still potentially abort the route.\"\n  [denied-target-instance relative-root path]\n  #?(:cljs\n     (do\n       (log/debug \"Retrying route at the request of \" (rc/component-name denied-target-instance))\n       (set-force-route-flag! denied-target-instance)\n       (change-route-relative! denied-target-instance relative-root path))))\n\n(defn change-route!\n  \"Trigger a route change.\n\n  * `this` - The component (or app) that is causing the route change.\n  * `new-route` - A vector of URI components to pass to the router.\n  * `timeouts-and-params` - A map of additional parameters and route timeouts that affect UI during deferred routes:\n  `{:error-timeout ms :deferred-timeout ms}`.  Anything extra will appear in the `params` of `will-enter`.\n\n  The error timeout is how long to wait  (default 5000ms) before showing the error-ui of a route (which must be defined on the\n  router that is having problems).  The deferred-timeout (default 100ms) is how long to wait before showing the loading-ui of\n  a deferred router (to prevent flicker).\n\n  Returns one of:\n\n  `:already-there` - The old and new route are the same, and there was no request to force an idempotent routing operation.\n  `:invalid` - The new route didn't evaluate to a valid location\n  `:denied` - One or more on-screen targets refused to allow the routing operation\n  `:routing` - The routing operation is in progress, but deferred operations may still delay the route becoming visible.\n  \"\n  ([this new-route]\n   (change-route! this new-route {}))\n  ([this new-route timeouts-and-params]\n   (let [app  (rc/any->app this)\n         root (app/root-class app)]\n     (change-route-relative! app root new-route timeouts-and-params))))\n\n(def change-route change-route!)\n\n#?(:clj\n   (defn compile-error [env form message]\n     (throw (ana/error (merge env (some-> form meta)) message))))\n\n#?(:clj (s/def ::router-targets (s/coll-of symbol? :type vector?)))\n#?(:clj (s/def ::always-render-body? boolean?))\n#?(:clj (s/def ::defrouter-options (s/keys :req-un [::router-targets] :opt-un [::always-render-body?])))\n\n(defn validate-route-targets\n  \"Run a runtime validation on route targets to verify that they at least declare a route-segment that is a vector.\"\n  [router-instance]\n  (doseq [t (get-targets router-instance)\n          :let [segment (route-segment t)\n                valid?  (and\n                          (vector? segment)\n                          (not (empty? segment))\n                          (every? #(or (keyword? %) (string? %)) segment))]]\n    (when-not valid?\n      (log/error \"Route target \"\n        (rc/component-name t)\n        \"of router\"\n        (rc/component-name router-instance)\n        \"does not declare a valid :route-segment. Route segments must be non-empty vector that contain only strings\"\n        \"and keywords. See https://book.fulcrologic.com/#err-dr-target-lacks-r-segment\"))))\n\n#?(:clj\n   (defn defrouter* [env router-ns router-sym arglist options body]\n     (when-not (and (vector? arglist) (= 2 (count arglist)))\n       (compile-error env options \"defrouter argument list must have an entry for this and props.\"))\n     (when-not (map? options)\n       (compile-error env options \"defrouter requires a literal map of options.\"))\n     (when-not (s/valid? ::defrouter-options options)\n       (compile-error env options (str \"defrouter options are invalid: \" (s/explain-str ::defrouter-options options))))\n     (let [{:keys [router-targets]} options\n           _                      (when (empty? router-targets)\n                                    (compile-error env options \"defrouter requires at least one router-target\"))\n           id                     (keyword router-ns (name router-sym))\n           getq                   (fn [s] `(or (rc/get-query ~s)\n                                             (throw (ex-info (str \"Route target has no query! \"\n                                                               (rc/component-name ~s)) {}))))\n           query                  (into [::id\n                                         [::uism/asm-id id]\n                                         {::current-route (getq (first router-targets))}]\n                                    (map-indexed\n                                      (fn [idx s]\n                                        (when (nil? s)\n                                          (compile-error env options \"defrouter :target contains nil!\"))\n                                        {(keyword (str \"alt\" idx)) (getq s)})\n                                      (rest router-targets)))\n           initial-state-map      (into {::id            id\n                                         ::current-route `(rc/get-initial-state ~(first router-targets) ~'params)}\n                                    (map-indexed\n                                      (fn [idx s] [(keyword (str \"alt\" idx)) `(rc/get-initial-state ~s {})])\n                                      (rest router-targets)))\n           ident-method           (apply list `(fn [] [::id ~id]))\n           initial-state-lambda   (apply list `(fn [~'params] ~initial-state-map))\n           states-to-render-route (if (seq body)\n                                    #{:routed :deferred}\n                                    `(constantly true))\n           always-render-body?    (and (map? options) (:always-render-body? options))\n           render-cases           (if always-render-body?\n                                    (apply list `(let [~'class (current-route-class ~'this)]\n                                                   (let [~(first arglist) ~'this\n                                                         ~(second arglist) {:pending-path-segment ~'pending-path-segment\n                                                                            :route-props          ~'current-route\n                                                                            :route-factory        (when ~'class (comp/factory ~'class))\n                                                                            :current-state        ~'current-state\n                                                                            :router-state         (get-in ~'props [[::uism/asm-id ~id] ::uism/local-storage])}]\n                                                     ~@body)))\n                                    (apply list `(let [~'class (current-route-class ~'this)]\n                                                   (if (~states-to-render-route ~'current-state)\n                                                     (when ~'class\n                                                       (let [~'factory (comp/factory ~'class)]\n                                                         (~'factory (rc/computed ~'current-route (rc/get-computed ~'this)))))\n                                                     (let [~(first arglist) ~'this\n                                                           ~(second arglist) {:pending-path-segment ~'pending-path-segment\n                                                                              :route-props          ~'current-route\n                                                                              :route-factory        (when ~'class (comp/factory ~'class))\n                                                                              :current-state        ~'current-state}]\n                                                       ~@body)))))\n           options                (merge\n                                    `{:componentDidMount (fn [this#] (validate-route-targets this#))}\n                                    options\n                                    `{:query                   ~query\n                                      :ident                   ~ident-method\n                                      :use-hooks?              false\n                                      :initial-state           ~initial-state-lambda\n                                      :preserve-dynamic-query? true})]\n       `(comp/defsc ~router-sym [~'this {::keys [~'id ~'current-route] :as ~'props}]\n          ~options\n          (let [~'current-state (uism/get-active-state ~'this ~id)\n                ~'state-map (comp/component->state-map ~'this)\n                ~'sm-env (uism/state-machine-env ~'state-map nil ~id :fake {})\n                ~'pending-path-segment (when (uism/asm-active? ~'this ~id) (uism/retrieve ~'sm-env :pending-path-segment))]\n            ~render-cases)))))\n\n#?(:clj\n   (s/fdef defrouter\n     :args (s/cat :sym symbol? :arglist vector? :options map? :body (s/* any?))))\n\n#?(:clj\n   (defmacro defrouter\n     \"Define a router.\n\n     The arglist is `[this props]`, which are just like defsc. The props will contains :current-state and :pending-path-segment.\n\n     The options are:\n\n     `:router-targets` - (REQUIRED) A *vector* of ui components that are router targets. The first one is considered the \\\"default\\\"\n     (purely for the purpose of initial state; you always need to explicitly route to a particular target).\n     Other defsc options - (LIMITED) You may not specify query/initial-state/protocols/ident, but you can define things like react\n     lifecycle methods. See defsc.\n     `:always-render-body?` - (OPTIONAL) When true this router expects that you will supply a render body, and\n     it will always be rendered. The props available in the body will include:\n\n     - `:current-state` - The state of the routing state machine. (:initial, :pending, :failed, :routed)\n     - `:route-factory` - A factory that can generate the current route.\n     - `:route-props` -  The props that should be passed to the route factory. You can augment these with computed if you\n     wish. The router normally passes computed through like so: `(route-factory (comp/computed route-props (comp/get-computed this)))`\n     - `:pending-path-segment` - The route that we're going to (when in pending state).\n     - `:router-state` - A map of the path management details of the router. Includes the pending path segment (if deferred), the\n       target, and the path segment of the current route.\n\n     The optional body, if defined, will *only* be used if the router has the `:always-render-body?` option set or\n     it is in one of the following states:\n\n     - `:initial` - No route is set.\n     - `:pending` - A deferred route is taking longer than expected (configurable timeout, default 100ms)\n     - `:failed` - A deferred route took longer than can reasonably be expected (configurable timeout, default 5s)\n\n     otherwise the actual active route target will be rendered.\n     \"\n     [router-sym arglist options & body]\n     (defrouter* &env (str (ns-name *ns*)) router-sym arglist options body)))\n\n(defn all-reachable-routers\n  \"Returns a sequence of all of the routers reachable in the query of the app.\"\n  [state-map component-class]\n  (let [root-query  (rc/get-query component-class state-map)\n        {:keys [children]} (eql/query->ast root-query)\n        get-routers (fn get-routers* [nodes]\n                      (reduce\n                        (fn [acc {:keys [component children]}]\n                          (into (if (router? component)\n                                  (conj acc component)\n                                  acc)\n                            (get-routers* children)))\n                        []\n                        nodes))]\n    (get-routers children)))\n\n\n(defn initialize!\n  \"Initialize the routing system.  This ensures that all routers have state machines in app state.\"\n  [app]\n  (let [state-map (app/current-state app)\n        root      (app/root-class app)\n        routers   (all-reachable-routers state-map root)\n        tx        (mapv (fn [r]\n                          (let [router-ident (rc/get-ident r {})\n                                router-id    (second router-ident)]\n                            (uism/begin {::uism/asm-id           router-id\n                                         ::uism/state-machine-id (::uism/state-machine-id RouterStateMachine)\n                                         ::uism/event-data       {:path-segment []\n                                                                  :router       (vary-meta router-ident assoc :component r)}\n                                         ::uism/actor->ident     {:router (uism/with-actor-class router-ident r)}}))) routers)]\n    (rc/transact! app tx)))\n\n(defn into-path\n  \"Returns the given `prefix` with the TargetClass segment appended onto it, replacing the final elements with the\n   given (optional) path args.\n\n  ```\n  (defsc X [_ _]\n    {:route-segment [\\\"a\\\" :b]})\n\n  (into [\\\"f\\\" \\\"g\\\"] X \\\"22\\\") ; => [\\\"f\\\" \\\"g\\\" \\\"a\\\" \\\"22\\\"]\n  ```\n  \"\n  [prefix TargetClass & path-args]\n  (let [nargs           (count path-args)\n        path            (some-> TargetClass rc/component-options :route-segment)\n        static-elements (- (count path) nargs)]\n    (into prefix (concat (take static-elements path) path-args))))\n\n(defn subpath\n  \"Returns the route segment of the given TargetClass with the trailing elements replaced by path-args.\n\n  ```\n  (defsc X [_ _]\n    {:route-segment [\\\"a\\\" :b]})\n\n  (subpath X \\\"22\\\") ; => [\\\"a\\\" \\\"22\\\"]\n  ```\n  \"\n  [TargetClass & path-args]\n  (apply into-path [] TargetClass path-args))\n\n(defn path-to\n  \"Convert a sequence of router targets and parameters into a vector of strings that represents the target route. Parameters\n  can be sequenced inline:\n\n  ```\n  (defsc A [_ _]\n    {:route-segment [\\\"a\\\" :a-param]})\n\n  (defsc B [_ _]\n    {:route-segment [\\\"b\\\" :b-param]})\n\n  (route-segment A a-param1 B b-param ...)\n  ```\n\n  where the parameters for a target immediately follow the component that requires them. Alternatively\n  one can specify all of the parameters at the end as a single map using the parameter names that are used in\n  the component `:route-segment` itself:\n\n  ```\n  (defsc A [_ _]\n    {:route-segment [\\\"a\\\" :a-param]})\n\n  (route-segment A B C D {:a-param 1})\n  ```\n  \"\n  ([& targets-and-params]\n   (let [segments (seq (partition-by #(and\n                                        #?(:clj true :cljs (fn? %))\n                                        (or\n                                          (rc/component? %)\n                                          (rc/component-class? %))) targets-and-params))]\n     (if (and (= 2 (count segments)) (map? (first (second segments))))\n       (let [path   (mapcat #(rc/component-options % :route-segment) (first segments))\n             params (first (second segments))]\n         (mapv (fn [i] (get params i i)) path))\n       (reduce\n         (fn [path [classes params]]\n           (-> path\n             (into (mapcat #(rc/component-options % :route-segment) (butlast classes)))\n             (into (apply subpath (last classes) params))))\n         []\n         (partition-all 2 segments))))))\n\n(defn resolve-path-components\n  [StartingClass RouteTarget]\n  (if (rc/component-options RouteTarget :route-segment)\n    (let [query     (rc/get-query StartingClass)\n          root-node (eql/query->ast query)\n          zipper    (zip/zipper #(contains? % :children) :children (fn [n children] (assoc n :children children)) root-node)\n          node      (->> zipper\n                      (iterate zip/next)\n                      (drop-while (fn [n]\n                                    (let [{:keys [component]} (zip/node n)]\n                                      (and\n                                        (not= component RouteTarget)\n                                        (not (zip/end? n))))))\n                      first)\n          found?    (= RouteTarget (some-> node zip/node :component))]\n      (when found?\n        (conj (->> node zip/path (map :component) vec) RouteTarget)))\n    nil))\n\n(defn resolve-path\n  \"Attempts to resolve a path from StartingClass to the given RouteTarget. Can also be passed `resolved-components`, which\n  is the output of `resolve-path-components`.\n\n   Returns a vector of route segments. Any keywords in the result will be replaced by the values from `params`, if present.\n\n   Returns nil if no path can be found.\"\n  ([resolved-components params]\n   (when (seq resolved-components)\n     (let [base-path (into []\n                       (mapcat #(rc/component-options % :route-segment))\n                       resolved-components)]\n       (mapv (fn [ele]\n               (if (contains? params ele)\n                 (str (get params ele))\n                 ele)) base-path))))\n  ([StartingClass RouteTarget params]\n   (resolve-path (resolve-path-components StartingClass RouteTarget) params)))\n\n(defn resolve-target\n  \"Given a new-route path (vector of strings): resolves the target (class) that is the ultimate target of that path.\"\n  [app new-route]\n  (let [state-map  (app/current-state app)\n        root-query (rc/get-query (app/root-class app) state-map)\n        ast        (eql/query->ast root-query)\n        root       (ast-node-for-route ast new-route)]\n    (loop [{:keys [component]} root path new-route]\n      (when (and component (router? component))\n        (let [{:keys [target matching-prefix]} (route-target component path)\n              target-ast     (some-> target (rc/get-query state-map) eql/query->ast)\n              prefix-length  (count matching-prefix)\n              remaining-path (vec (drop prefix-length path))]\n          (if (seq remaining-path)\n            (recur (ast-node-for-route target-ast remaining-path) remaining-path)\n            target))))))\n\n(letfn [(active-routes* [state-map {:keys [path] :as result} parent-component ast-nodes]\n          (let [segment (some-> parent-component (route-segment))]\n            (cond\n              (nil? parent-component) [result]\n\n              (some-> parent-component (router?))\n              (let [ident           (some-> parent-component (comp/get-ident {}))\n                    active-ast-node (first\n                                      (filter (fn [{:keys [dispatch-key]}]\n                                                (= ::current-route dispatch-key))\n                                        ast-nodes))\n                    new-parent      (:component active-ast-node)]\n                (active-routes* state-map {:path         (into path segment)\n                                           ;:target-ident ident ;; Need to follow along in state to get the proper ident...\n                                           :target-class parent-component} new-parent (:children active-ast-node)))\n\n              segment\n              (let [subpath (into path segment)]\n                (mapcat\n                  (fn [{:keys [component children] :as node}]\n                    (active-routes* state-map {:path         subpath\n                                               ;:target-ident ident\n                                               :target-class parent-component} component children))\n                  ast-nodes))\n\n              :else\n              (mapcat\n                (fn [{:keys [component children] :as node}]\n                  (active-routes* state-map result component children))\n                ast-nodes))))]\n  (defn active-routes\n    \"Return a sequence of the leaf router targets that are routed to in the given app using the active dynamic query\n     and app state.\n\n     The return values are maps that currently contain a `:path` and `:target-component` key.\n     Future versions of this function may include additional information.\n\n     Note that dynamic routing purposely supports the ability to have more than one UI path active at a time, as it\n     is NOT a strict URL-style UI router. However, since your code is ultimately responsible for determining what\n     parts of the active query are rendered, it is possible for this to return routes that are available (in the props\n     of components) but are not being rendered by your logic. Thus, the return value of this function isn't necessarily\n     proof that the routes listed are visible to the user.\n\n     WARNING: If you use disconnected roots (via hooks or otherwise), then you must specify a starting component that is\n     well-connected (graph/state) from which to scan, and will get back paths relative to that `starting-from`\n     (a component, element, or factory if you're using factory-based dynamic queries).\"\n    ([app]\n     (active-routes app (app/app-root app)))\n    ([app starting-from]\n     (let [state-map (app/current-state app)\n           query     (comp/get-query starting-from state-map)\n           {:keys [children]} (eql/query->ast query)]\n       (set (active-routes* state-map {:path []} starting-from children))))))\n"]}